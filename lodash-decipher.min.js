/*! lodash-decipher - v0.1.0 - 2014-11-18
* https://github.com/decipherinc/lodash-decipher
* Copyright (c) 2014 Decipher, Inc.; Licensed MIT */
!function(t,n){"function"==typeof define&&define.amd?define(["../lodash"],n):"object"==typeof exports?module.exports=n(require("lodash")):t.gulpWrapUmd=n(t._)}(this,function(t){return function(){"use strict";var n=function(t,n,i,r){return this.isObject(t)&&!this.isFunction(t)&&(t=this[this.isArray(t)?n:i].apply(this,r)),t},i=function(){},r=function(n){return t.isObject(n)?function(i){t.isObject(i)&&t.extend(i,n)}:i},e=function(n,r){return t.isString(n)?function(i){t.isObject(i)&&(i[n]=r)}:i},s={flattenPrototype:function(n){var i,r={},e=Object.getPrototypeOf;if(!this.isObject(n))return n;for(i=e(n);null!==i&&i!==Object.prototype;)t.extend(r,i),i=e(i);return r},applicator:function(t,n,i){var r=this;return this.isString(t)?function(e){return r.isObject(e)&&r.isFunction(e[t])?e[t].apply(i||e,n||[]):e}:r.identity},isDefined:function(t){return!this.isUndefined(t)},format:function(t){var n,i;return this.isString(t)&&(n=/(%[sdfj])/,i={"%s":function(t){return t.toString()},"%j":function(t){return JSON.stringify(t)},"%d":function(t){return parseInt(t,10)},"%f":function(t){return parseFloat(t)}},this(arguments).toArray().slice(1).each(function(r){var e,s=t.match(n);if(s&&(e=i[s[1]],this.isFunction(e)))try{t=t.replace(n,e(r))}catch(u){}},this)),t}},u={transmogrify:function(t,n,i){var r=this,e=function(t,n){return r.isObject(t)&&!r.isFunction(t)&&(!n||i.test(n))},s=function c(t,i,s){var o=n(t);return r.contains(u,t)||(u.push(t),e(o)&&r.extend(o,r(o).sift(e).morph(function(t,n){return c(t,n,o)}).value())),i&&(s[i]=o),o},u=[];return i=i||/^[^$]/,r.isString(i)&&(i=new RegExp(i)),n=n||r.identity,s(t)},morph:function(t){return n.call(this,t,"map","mapValues",arguments)},sift:function(t){return n.call(this,t,"filter","pick",arguments)},squirt:function(t,n,i){var s;return s=this.isObject(n)?r(n):e(n,i),this.each(t||[],s)},empty:function(t){return this.isObject(t)&&(this.isArray(t)?t.length=0:this(t).keys().each(function(n){delete t[n]})),t}};t.mixin(s),t.mixin(t,u,{chain:!0})}()});